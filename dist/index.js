var c=class{static getIndexOfArrayMax(e){if(!Array.isArray(e))throw Error("arrayOfNumbers is not an array");if(e.length==0)throw Error("arrayOfNumbers contains no elements");let t=0,r=e[0];for(let n=0;n<e.length;n++){let o=e[n];o>r&&(r=o,t=n)}return t}static isMixedUpArraysEqual(e,t){if(e.length!==t.length)return!1;e=[...e],t=[...t];for(let r=e.length-1;r>=0;r--)for(let n=t.length-1;n>=0;n--)e[r]===t[n]&&(e.splice(r,1),t.splice(n,1));return e.length==0&&t.length==0}static isThereValueGreaterThanN(e,t){for(let r of e)if(r>t)return!0;return!1}static combineArrays(e){let t=[];for(let r of e)for(let n of r)t.push(n);return t}static arrayOfIndices(e){let t=[];for(let r=0;r<e;r++)t.push(r);return t}static addToMap(e,t,r){e.has(t)||e.set(t,[]);let n=e.get(t).push(r);return e}static incrementMap(e,t){if(!e.has(t))throw new Error("Supplied map is bad");e.set(t,e.get(t)+1)}static isInArray(e,t){for(let r=0;r<e.length;r++)if(e[r]===t)return!0;return!1}static getCounterClockwiseMove(e,t){if(!e.has(t))throw Error("Key not found");let r=[...e.get(t)];if(r.length==1)return t=r[0],t;for(let n=r.length-1;n>=0;n--)this.doesMoveExistElsewhere(e,t,r[n])&&r.splice(n,1);return r[0]}static doesMoveExistElsewhere(e,t,r){if(e.has(t)==!1)throw new Error("Could not find node");return this.isInArray(e.get(r),t)}static doesKeyHaveSpecificValue(e,t,r){if(!e.has(t))throw Error("Key not found in hash graph");let n=e.get(t);for(let o=0;o<n.length;o++)if(n[o]===r)return!0;return!1}static findNodeThatHasSpecificNodeAsConnection(e,t,r,n){if(!e.has(t))throw Error("Key not found in hash graph");let o=e.get(t);for(let i=0;i<o.length;i++)if(o[i]!==n&&this.doesKeyHaveSpecificValue(e,o[i],r))return o[i];return-1}static runSearchMovementAroundCenter(e,t,r,n,o){let i=100,s=1,u=r,l=n,a=t;for(;u!=a;){if(s++,s>i||u==-1)return!1;let f=u;u=this.findNodeThatHasSpecificNodeAsConnection(e,u,l,o),o=f}return!0}static isNodeSurroundedByNodes(e,t){if(!e.has(t))throw Error("Key not found in hash graph");let r=e.get(t),n=1,o=100,i=[];for(let s=0;s<r.length;s++){let u=r[s],l=u,a=this.findNodeThatHasSpecificNodeAsConnection(e,u,t,l),f=this.runSearchMovementAroundCenter(e,u,a,t,l);i.push(f)}return this.isInArray(i,!0)}static getOutsideNode(e){for(let t of e.keys())if(!this.isNodeSurroundedByNodes(e,t))return t;return-1}static randomIntBetween(e,t){let r=Math.round(Math.random()*(t-e));return e+r}static multiplyArray(e,t){let r=[];for(let n of e)r.push(n*t);return r}static divideArray(e,t){if(t==0)throw new Error("Divisor is 0, critical failure, cannot divide by zero!");let r=[];for(let n of e)r.push(n/t);return r}static elementWiseMultiplication(e,t){if(e.length!=t.length)throw new Error("Array lengths are different!");let r=[];for(let n=0;n<e.length;n++)r.push(e[n]*t[n]);return r}static randomP5Color(){return"rgb("+Math.round(Math.random()*255)+","+Math.round(Math.random()*255)+","+Math.round(Math.random()*255)+")"}static getNodesOnOutsideOfCounterClockwiseGraph(e,t){t==null&&(t=15);let r=1,n=new Map(e),o=this.getOutsideNode(e),i=this.getCounterClockwiseMove(e,o),s=[];for(;r<t&&i!=o;){r++;let u=this.getCounterClockwiseMove(e,i);s.push(i),i=u}return s.push(i),s}static addNumbersToNumberArray(e,t){let r=[...e];for(let n of t)r.push(n);return r}static removeIndicesFromArray(e,t){e=[...e];let r;for(let n=t.length-1;n>=0;n--)r=t[n],e.splice(r,1);return e}static clampNumber(e,t,r){return e=e>r?r:e,e=e<t?t:e,e}};c.noDuplicates=e=>[...new Set(e)];export{c as UsefulFunction};
